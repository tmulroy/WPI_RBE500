// Generated by gencpp from file pa1/HTRequest.msg
// DO NOT EDIT!


#ifndef PA1_MESSAGE_HTREQUEST_H
#define PA1_MESSAGE_HTREQUEST_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace pa1
{
template <class ContainerAllocator>
struct HTRequest_
{
  typedef HTRequest_<ContainerAllocator> Type;

  HTRequest_()
    : ht11(0.0)
    , ht12(0.0)
    , ht13(0.0)
    , ht14(0.0)
    , ht21(0.0)
    , ht22(0.0)
    , ht23(0.0)
    , ht24(0.0)
    , ht31(0.0)
    , ht32(0.0)
    , ht33(0.0)
    , ht34(0.0)
    , ht41(0.0)
    , ht42(0.0)
    , ht43(0.0)
    , ht44(0.0)  {
    }
  HTRequest_(const ContainerAllocator& _alloc)
    : ht11(0.0)
    , ht12(0.0)
    , ht13(0.0)
    , ht14(0.0)
    , ht21(0.0)
    , ht22(0.0)
    , ht23(0.0)
    , ht24(0.0)
    , ht31(0.0)
    , ht32(0.0)
    , ht33(0.0)
    , ht34(0.0)
    , ht41(0.0)
    , ht42(0.0)
    , ht43(0.0)
    , ht44(0.0)  {
  (void)_alloc;
    }



   typedef double _ht11_type;
  _ht11_type ht11;

   typedef double _ht12_type;
  _ht12_type ht12;

   typedef double _ht13_type;
  _ht13_type ht13;

   typedef double _ht14_type;
  _ht14_type ht14;

   typedef double _ht21_type;
  _ht21_type ht21;

   typedef double _ht22_type;
  _ht22_type ht22;

   typedef double _ht23_type;
  _ht23_type ht23;

   typedef double _ht24_type;
  _ht24_type ht24;

   typedef double _ht31_type;
  _ht31_type ht31;

   typedef double _ht32_type;
  _ht32_type ht32;

   typedef double _ht33_type;
  _ht33_type ht33;

   typedef double _ht34_type;
  _ht34_type ht34;

   typedef double _ht41_type;
  _ht41_type ht41;

   typedef double _ht42_type;
  _ht42_type ht42;

   typedef double _ht43_type;
  _ht43_type ht43;

   typedef double _ht44_type;
  _ht44_type ht44;





  typedef boost::shared_ptr< ::pa1::HTRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::pa1::HTRequest_<ContainerAllocator> const> ConstPtr;

}; // struct HTRequest_

typedef ::pa1::HTRequest_<std::allocator<void> > HTRequest;

typedef boost::shared_ptr< ::pa1::HTRequest > HTRequestPtr;
typedef boost::shared_ptr< ::pa1::HTRequest const> HTRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::pa1::HTRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::pa1::HTRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::pa1::HTRequest_<ContainerAllocator1> & lhs, const ::pa1::HTRequest_<ContainerAllocator2> & rhs)
{
  return lhs.ht11 == rhs.ht11 &&
    lhs.ht12 == rhs.ht12 &&
    lhs.ht13 == rhs.ht13 &&
    lhs.ht14 == rhs.ht14 &&
    lhs.ht21 == rhs.ht21 &&
    lhs.ht22 == rhs.ht22 &&
    lhs.ht23 == rhs.ht23 &&
    lhs.ht24 == rhs.ht24 &&
    lhs.ht31 == rhs.ht31 &&
    lhs.ht32 == rhs.ht32 &&
    lhs.ht33 == rhs.ht33 &&
    lhs.ht34 == rhs.ht34 &&
    lhs.ht41 == rhs.ht41 &&
    lhs.ht42 == rhs.ht42 &&
    lhs.ht43 == rhs.ht43 &&
    lhs.ht44 == rhs.ht44;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::pa1::HTRequest_<ContainerAllocator1> & lhs, const ::pa1::HTRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace pa1

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::pa1::HTRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::pa1::HTRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pa1::HTRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::pa1::HTRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pa1::HTRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::pa1::HTRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::pa1::HTRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b73c7247aab620f8f17139f7c17d037f";
  }

  static const char* value(const ::pa1::HTRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb73c7247aab620f8ULL;
  static const uint64_t static_value2 = 0xf17139f7c17d037fULL;
};

template<class ContainerAllocator>
struct DataType< ::pa1::HTRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "pa1/HTRequest";
  }

  static const char* value(const ::pa1::HTRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::pa1::HTRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float64 ht11\n"
"float64 ht12\n"
"float64 ht13\n"
"float64 ht14\n"
"float64 ht21\n"
"float64 ht22\n"
"float64 ht23\n"
"float64 ht24\n"
"float64 ht31\n"
"float64 ht32\n"
"float64 ht33\n"
"float64 ht34\n"
"float64 ht41\n"
"float64 ht42\n"
"float64 ht43\n"
"float64 ht44\n"
;
  }

  static const char* value(const ::pa1::HTRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::pa1::HTRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.ht11);
      stream.next(m.ht12);
      stream.next(m.ht13);
      stream.next(m.ht14);
      stream.next(m.ht21);
      stream.next(m.ht22);
      stream.next(m.ht23);
      stream.next(m.ht24);
      stream.next(m.ht31);
      stream.next(m.ht32);
      stream.next(m.ht33);
      stream.next(m.ht34);
      stream.next(m.ht41);
      stream.next(m.ht42);
      stream.next(m.ht43);
      stream.next(m.ht44);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct HTRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::pa1::HTRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::pa1::HTRequest_<ContainerAllocator>& v)
  {
    s << indent << "ht11: ";
    Printer<double>::stream(s, indent + "  ", v.ht11);
    s << indent << "ht12: ";
    Printer<double>::stream(s, indent + "  ", v.ht12);
    s << indent << "ht13: ";
    Printer<double>::stream(s, indent + "  ", v.ht13);
    s << indent << "ht14: ";
    Printer<double>::stream(s, indent + "  ", v.ht14);
    s << indent << "ht21: ";
    Printer<double>::stream(s, indent + "  ", v.ht21);
    s << indent << "ht22: ";
    Printer<double>::stream(s, indent + "  ", v.ht22);
    s << indent << "ht23: ";
    Printer<double>::stream(s, indent + "  ", v.ht23);
    s << indent << "ht24: ";
    Printer<double>::stream(s, indent + "  ", v.ht24);
    s << indent << "ht31: ";
    Printer<double>::stream(s, indent + "  ", v.ht31);
    s << indent << "ht32: ";
    Printer<double>::stream(s, indent + "  ", v.ht32);
    s << indent << "ht33: ";
    Printer<double>::stream(s, indent + "  ", v.ht33);
    s << indent << "ht34: ";
    Printer<double>::stream(s, indent + "  ", v.ht34);
    s << indent << "ht41: ";
    Printer<double>::stream(s, indent + "  ", v.ht41);
    s << indent << "ht42: ";
    Printer<double>::stream(s, indent + "  ", v.ht42);
    s << indent << "ht43: ";
    Printer<double>::stream(s, indent + "  ", v.ht43);
    s << indent << "ht44: ";
    Printer<double>::stream(s, indent + "  ", v.ht44);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PA1_MESSAGE_HTREQUEST_H
